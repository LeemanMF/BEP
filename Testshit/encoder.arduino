#include <Wire.h>
#include <Adafruit_MotorShield.h>

// Define constants
#define GEARING     120      // Gear ratio
#define ENCODER_PPR 8      // Pulses per revolution of the encoder
#define SAMPLE_INTERVAL 1000 // Time interval for sampling RPM in milliseconds

// Initialize the motor shield
Adafruit_MotorShield AFMS = Adafruit_MotorShield(); 

// Motor objects
Adafruit_DCMotor *myMotor = AFMS.getMotor(1); // M1

// Encoder pins
const int encoderPinA = 1;  // A output of the encoder connected to digital pin 2
const int encoderPinB = 7;  // B output of the encoder connected to digital pin 3

// Encoder variables
volatile long encoderTicks = 0;
volatile unsigned long lastTickTime = 0;

void setup() {
  Serial.begin(9600);  // Initialize serial communication

  AFMS.begin();  // Initialize motor shield
  
  myMotor->setSpeed(150); // Set motor speed to 100 out of 255
  myMotor->run(FORWARD);  // Run motor in the forward direction

  // Set encoder pins as inputs
  pinMode(encoderPinA, INPUT);
  pinMode(encoderPinB, INPUT);

  // Attach interrupts to handle encoder pulses
  attachInterrupt(digitalPinToInterrupt(encoderPinA), handleEncoderInterrupt, CHANGE);
}

void loop() {
  // Your motor control code goes here
  
  // Check if it's time to sample RPM
  unsigned long currentTime = millis();
  if (currentTime - lastTickTime >= SAMPLE_INTERVAL) {
    // Calculate RPM
    float rpm = calculateRPM();
    Serial.print("RPM: ");
    Serial.println(rpm);

    // Reset encoder ticks and update last tick time
    encoderTicks = 0;
    lastTickTime = currentTime;
  }
}

// Pin change interrupt handler
void handleEncoderInterrupt() {
  // Handle encoder interrupt by reading both A and B pins
  int pinAState = digitalRead(encoderPinA);
  int pinBState = digitalRead(encoderPinB);

  // Determine direction of rotation based on the states of A and B pins
  if (pinAState == HIGH) {
    if (pinBState == LOW) {
      encoderTicks++;
    } else {
      encoderTicks--;
    }
  } else {
    if (pinBState == LOW) {
      encoderTicks--;
    } else {
      encoderTicks++;
    }
  }
}

// Function to calculate RPM
float calculateRPM() {
  // Calculate time taken for one complete revolution in milliseconds
  unsigned long timePerRevolution = SAMPLE_INTERVAL;

  // Calculate RPM
  float rpm =  encoderTicks;
  return rpm;
}

//float rpm = (60000.0 / timePerRevolution) * (encoderTicks / (float)(GEARING * ENCODER_PPR));
