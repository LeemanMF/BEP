mc = 1.0e5  # Mass of the crane [kg]
mt = 6.3e5  # Mass of the tower [kg]
b = 1e5     # Translational friction of crane [Ns/m]
l = 110/2   # The tower is assumed to be a point mass at half the tower height [kg]
I = mt*l**2 # Inertia of the tower [kg m^2]
g = 9.81    # Gravitational constant [m/s^2]

A = np.array([[0, g/l, 0, 0], [1, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]])
B = np.array([[1], [0], [0], [0]])
C = np.array([[0, 0, 0, 0], [1, 0, 0, 0]])
D = np.array([[0], [0]])

states = ["x_ddot", "x", "y_dot", "y"]
inputs = ["theta"]
outputs = ["x", "y"]

den = mt*mc*l**2 + I*(mt+mc)

num_a1 = -(l*mt*g*(mt+mc))
num_a2 = b*l*mt
num_a3 = g*l**2*mt**2
num_a4 = -(b*mt*l**2 + I*b)

num_b1 = -(l*mt)
num_b2 = mt*l**2+I

# Define state-space matrices A and B (you do not NOT have to change this)
A = np.array([[0, num_a1/den, num_a2/den, 0], [1, 0, 0, 0], [0, num_a3/den, num_a4/den, 0], [0, 0, 1, 0]])
B = np.array([[num_b1/den], [0], [num_b2/den], [0]])
C = np.array([[0, 1, 0, 0], [0, 0, 0, 1]])
D = np.array([[0], [0]])

sys = cm.ss(A, B, C, D, states=states, input=inputs, output=outputs)

################ /Copy

BSCALE = 1e5

A_L = A.copy()
B_L = B.copy()*BSCALE
C_L = C.copy()
D_L = D.copy()

sys_L = cm.ss(A_L, B_L, C_L, D_L, states=states, input=inputs, output=outputs)

# Define state and input weight matrices (4 cases)
Qx1 = np.diag([1, 0, 0, 0]) # Equal penalization on tower angle and crane position, not on respective velocities
Qx2 = np.diag([0, 1, 0, 0]) # Same, but higher penalization on the crane position
Qx3 = np.diag([0, 0, 0, 0]) # Same as Case #2, but see below for higher input penalization
Qx4 = np.diag([0, 0, 0, 0]) # Same, but higher penalization on the tower angle

Qu1 = np.array([[1]])
Qu2 = np.array([[1]])
Qu3 = np.array([[0]])
Qu4 = np.array([[0]])

### Setting up the plots
fig, ax = plt.subplots(nrows=1, ncols=2, figsize=(12, 4))
fig_2 = plt.figure(figsize=(12,4))
ax_u = fig_2.add_subplot(1,2,1)
ax_p = fig_2.add_subplot(1,2,2)

legend_string = ["Case 1", "Case 2", "Case 3", "Case 4"]
title_string = "Step response: LQR controller design"

# Set title, grid and labels
fig.suptitle(title_string);

ax[0].set_xlabel("time [s]");
ax[0].set_ylabel(r"$\theta$ (rad)");
ax[0].grid(True);

ax[1].set_xlabel("time (s)");
ax[1].set_ylabel(r"$q$ (m)");
ax[1].grid(True);

ax_p.grid()
ax_u.grid()

#Simulation time vector
t_max = 100
t_begin_end = np.arange(0, t_max, 0.01)
U = np.heaviside(t_begin_end, 1)
U = U[:, np.newaxis]    

# Perform LQR design, controller implementation and simulation
# for all 3 cases
for ii, (Qx, Qu) in enumerate(zip([Qx1, Qx2, Qx3, Qx4], [Qu1, Qu2, Qu3, Qu4])):
    
    # Compute state-feedback gain using the LQR function
    K_LQR, _, eigLQR= cm.lqr(sys_L, Qx, Qu, method='scipy')

    # Select the crane position as a reference for tracking
    C_LQR = C[1, :]
    
    # Compute closed-loop A matrix
    A_LQR = A_L-B_L@K_LQR
    
    # Compute and apply reference gain
    kf_LQR = -1/(C_LQR@np.linalg.inv(A_LQR)@B_L)
    B_LQR = B_L*kf_LQR
    
    #Create state-space system object
    sys_LQR = cm.ss(A_LQR, B_LQR, C_L, D_L)
